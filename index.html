
<!-- v0.7.0, by quackbarc. Licensed under GPL 3.0 (https://www.gnu.org/licenses/gpl-3.0.en.html). -->
<!-- GIF generation website (garyc2gif.neocities.org) by yeen. -->

<!DOCTYPE html>
<html lang="en">
<head>
    <link href="https://fonts.googleapis.com/css2?family=Podkova&display=swap" rel="stylesheet">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>alt gallery for garyc.me</title>

    <style>
        /* Variables */

        :root,
        :root[theme="dark"] {
            --background-color: #111;
            --main-background-color: #222;
            --settings-background-color: #444;
            --text-color: #fff;
            --text-italic-color: #fff9;
            --text-anchor-color: #808fff;
            --refreshing-text-color: var(--text-italic-color);
            --color-scheme: dark;

            --tile-section-background-color: #fff;
            --tile-section-text-color: #000;
            --tile-section-2-background-color: #444;
            --tile-section-2-text-color: var(--text-color);

            --grid-image-size: 200px;
        }

        :root[theme="light"] {
            --background-color: #fff;
            --main-background-color: #eee;
            --settings-background-color: #ccc;
            --text-color: #000;
            --text-italic-color: #0009;
            --text-anchor-color: #484cbb;
            --refreshing-text-color: var(--text-italic-color);
            --color-scheme: light;

            --tile-section-background-color: #000;
            --tile-section-text-color: #fff;
            --tile-section-2-background-color: #bbb;
            --tile-section-2-text-color: var(--text-color);
        }

        /* Styles */

        *:not(
            .tile-section,
            .tile.not-found
        ) {
            /* For transitioning between themes. */
            transition: 0.2s background-color ease;
        }

        /* general styles */

        html {
            color-scheme: var(--color-scheme);
        }

        body {
            padding: 10px;
            font-family: "Podkova", sans-serif;
            max-width: 1000px;
            margin: auto;

            background-color: var(--background-color);
            color: var(--text-color);
        }

        a, a:visited {
            color: var(--text-anchor-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        i, i > a {
            color: var(--text-italic-color);
        }

        #version {
            /**
             * Podkova tends to add kerning to decimal numbers like on "6.7"
             * The version number looked weird with that. */
            font-kerning: none;
        }

        /* <header> styles */

        header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0px 12px;

            border-bottom: 2px #8884 dashed;
        }

        h1 {
            text-align: left;
            flex: 0 0 auto;
        }

        header > ul {
            text-align: left;
            list-style: none;
            padding: 0;
            font-size: 14px;

            flex: 1 0 auto;
        }

        nav {
            text-align: right;
            flex: 0 1 auto;
            align-self: flex-end;
            padding: 10px 0px;

            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        nav input {
            /**
             * Prefer light color-scheme for the nav inputs,
             * just so it stands out a little. */
            color-scheme: light;
        }

        nav .refresh-text {
            visibility: hidden;
            color: var(--refreshing-text-color);
        }

        nav .refresh-text.show {
            visibility: visible;
        }

        /* settings styles */

        #settings {
            /* styles specifically for its position in <main> */
            float: right;
            padding: 10px;
            margin: 0px 10px 10px;

            user-select: none;
            text-align: right;
            background-color: var(--settings-background-color);
            border-bottom: 2px solid #0003;
        }

        #settings > summary {
            cursor: pointer;
        }

        #settings > summary:hover {
            text-decoration: underline;
        }

        #settings[open] > summary {
            padding-bottom: 4px;
        }

        #settings > * > input,
        #settings > * > select {
            /**
             * Align the input elements to the bottom of the text.
             * Worked for checkboxes so far; hope it works for the others. */
            vertical-align: bottom;
        }

        #settings > * > input[type=number] {
            width: 3em;
        }

        #settings > * > input[type=number],
        #settings > * > select {
            margin: 0px 3px;
        }

        /* <footer> styles */

        footer {
            margin-top: 8px;
            text-align: center;
        }

        footer .filter-note-text {
            display: none;
            margin: 1em;
            font-size: 0.9em;
        }

        footer .filter-note-text.show {
            display: unset;
        }

        /* <main> styles */

        main {
            padding: 10px;
            border: 2px solid #0003;
            overflow-wrap: anywhere;

            background-color: var(--main-background-color);
            line-height: 1.3em;
        }

        #tiles {
            clear: both;
            overflow-x: auto;
        }

        .tile {
            display: flex;
            align-items: center;
            text-align: left;
            width: 100%;
            padding: 8px 0px;
            gap: 6px;

            /* for the column-based formats */
            grid-template-areas:
                "img  img"
                "capt stat";
            grid-template-columns: auto min-content;
        }

        .tile .tile-image-holder {
            grid-area: img;
            flex: 0 1 auto;
        }

        .tile .tile-image-holder:not(:has(img)),
        .tile img.tile-image {
            display: block;  /* https://stackoverflow.com/a/5804278 */
            width: 400px;

            border-bottom: 0px solid #484cbb;
            transition: 0.1s opacity ease;
        }

        .tile img.rendering,
        .tile img.loading {
            /* TODO: wait, shouldn't we just use a background instead? */
            opacity: 30%;
        }

        .tile .tile-caption {
            flex: 1 1 auto;
            padding: 0px 6px;
            margin: 0;
            grid-area: capt;
        }

        .tile .tile-actions {
            display: flex;
            gap: 8px;
            margin-block-start: 0.5em;
            padding-bottom: 0.5em;  /* Padding between this elem and potential scrollbar */
            overflow-x: auto;
        }

        .tile .tile-actions > * {
            flex: 0 0 auto;
        }

        .tile .tile-status {
            flex: 0 1 auto;
            writing-mode: vertical-rl;
            grid-area: stat;
        }

        .tile .tile-status span {
            display: inline-block;
            padding: 5px;
        }

        .tile .tile-status .new-status {
            background-color: #484cbb;
            color: #fff;
        }

        .tile.filtered {
            display: none !important;
        }

        .tile-section {
            position: relative;
            background-color: var(--tile-section-background-color);
            color: var(--tile-section-text-color);
            text-align: center;
            padding: 12px;
            margin: 8px 0px;
        }

        .tile-section.type-2 {
            background-color: var(--tile-section-2-background-color);
            color: var(--tile-section-2-text-color);
        }

        .tile-section.type-3 {
            background-color: #484cbb;
            color: #fff;
        }

        .tile-section + .tile-section {
            margin-top: 10px;
        }

        .tile-section a {
            color: inherit;
            cursor: pointer;
        }

        .tile-section .section-text-right {
            /**
             * Apparently top/left/right/bottom values are
             * relative to an ancestor that isn't `position: static`.
             * Therefore, .tile-section should be `position: relative`.
             * 
             * https://developer.mozilla.org/en-US/docs/Web/CSS/position#absolute_positioning
             */
            position: absolute;
            right: 0;

            /* Same as .tile-section's padding-right. */
            margin-right: 12px;
        }

        :root[theme="light"] .tile img.rendering {
            /* Silly little trick just to achieve a darker gray */
            filter: invert(30%);
        }

        /* block-based format */

        #tiles.block {
            text-align: center;
        }

        #tiles.block .tile:not(.expanded) {
            display: inline-block;
            vertical-align: top;  /* https://stackoverflow.com/a/5804278 */ /* <-- outdated comment */
            padding: 4px;
            width: auto;
        }

        #tiles.block .tile:not(.expanded) > :not(.tile-image-holder) {
            display: none;
        }

        #tiles.block .tile:not(.expanded) .tile-image-holder:not(:has(img)),
        #tiles.block .tile:not(.expanded) img.tile-image {
            width: var(--grid-image-size);
            box-shadow: 0px 0px 2px #0004;
        }

        #tiles.block .tile.new:not(.expanded) .tile-image-holder:not(:has(img)),
        #tiles.block .tile.new:not(.expanded) img.tile-image {
            border-bottom-width: 6px;
        }

        #tiles.block .tile.expanded {
            padding: 4px;  /* same as :not(.expanded) */
            margin: auto;
        }

        #tiles.block .tile.not-found {
            background-color: var(--background-color);
            margin: 4px;
        }

        /* wide block-based format */

        body.widened header,
        body.widened #prelude {
            max-width: 976px;  /* <body>'s max-width - (<main>'s margins + paddings) */
            margin-left: auto;
            margin-right: auto;
        }

        body.widened:has(#tiles.block) {
            max-width: none;
        }

        /* column-based format */

        .tile.expanded {
            display: grid;
            text-align: left;
            max-width: 800px;
            padding: 8px 0px;
            box-sizing: border-box;
        }

        .tile.expanded .tile-image-holder:not(:has(img)),
        .tile.expanded img.tile-image {
            width: 100%;
            border-bottom-width: 0;
        }

        .tile.expanded .tile-caption {
            padding: 6px 10px;
        }

        /* other media queries */

        @media not all and (hover: hover) {
            a:not([href]) {
                text-decoration: underline;
            }
        }

        @media (max-width: 800px) {
            .tile .tile-image-holder:not(:has(img)),
            .tile img.tile-image {
                width: 250px;
            }

            /* settings styles */

            #settings {
                float: none;
                text-align: left;
                margin-left: 0;
                margin-right: 0;
            }

            #settings .setting {
                display: flex;
            }

            #settings .setting label {
                flex-grow: 1;
            }
        }

        /* column-based format */

        @media (max-width: 550px) {
            /* <header> styles */

            header {
                display: grid;
                grid-template-areas:
                    "h1 h1 "
                    "ul nav";
                gap: 0px;
            }

            header > h1 {
                grid-area: h1;
            }

            header > ul {
                grid-area: ul;
            }

            header > nav {
                grid-area: nav;
            }

            /* <main> styles */

            .tile {
                padding: 8px 0px;
                display: grid;
            }
            .tile .tile-image-holder:not(:has(img)),
            .tile img.tile-image {
                width: 100%;
            }
            .tile .tile-caption {
                padding: 6px 10px;
            }
            .tile-section .section-text-right {
                position: revert;
                margin-right: 0;

                display: block;
            }

            /* block-based format */

            #tiles.block .tile:not(.expanded) .tile-image-holder:not(:has(img)),
            #tiles.block .tile:not(.expanded) img.tile-image {
                width: 160px;
            }
        }
    </style>

    <script>
        // @ts-check

        /* type definitions */

        /**
         * The archive details of a sketch.
         * 
         * @typedef {object} SketchDetails
         * @property {number} id
         * @property {string} data
         * @property {number} archive_timestamp
         * @property {number?} timestamp
         * @property {string?} origin
         */

        /**
         * The current statistics of the gallery.
         * 
         * @typedef {object} Stats
         * @property {number} sketches
         * @property {number} artists
         * @property {number} peekers
         * @property {number} minID
         * @property {number} maxID
         */

        /**
         * The state of the gallery from when it left off.
         * 
         * @typedef {object} GalleryState
         * @property {number} last_max
         * @property {number} last_updated
         */

        /**
         * The current loading state of the gallery's tiles.
         * 
         * @typedef {"idle" | "loading" | "gallery-end"} LoadingState
         */

        /**
         * The user configuration of the gallery. Settings, if you insist.
         *
         * @typedef {object} Settings
         * @property {boolean} endlessScroll
         * @property {boolean} gridView
         * @property {boolean} clickSaving
         * @property {boolean} clientSideRendering
         * @property {string} pageTheme
         * @property {number} gridImageSize
         * @property {boolean} wideGridView
         * @property {number} inkFilterThreshold
         */

        /* constants */

        const offcanv = new OffscreenCanvas(800, 600);
        const offctx = offcanv.getContext("2d", {alpha: false});
        initializeCanvas();

        /** @type {string?} */
        let missingSketch = null;
        const missingSketchPromise = render("").then((url) => {
            missingSketch = url;
        });

        // gallery settings

        const settings = getSettings();

        // gallery state

        /** @type {number?} */
        let min = null;
        /** @type {number?} */
        let max = null;
        /** @type {number?} */
        let first = null;
        /** @type {number?} */
        let last = null;
        /** @type {Date?} */
        let firstDate = null;
        /** @type {Date?} */
        let lastDate = null;
        /** Whether tiles are currently being added or not. */
        let sketchesLoading = false;
        /**
         * The current state of the gallery tile loading.
         * Currently unused.
         * 
         * @type {LoadingState}
         */
        let loadingState = "idle";
        /**
         * Whether the gallery is currently supposed to be showing the latest
         * sketches, or not.
         */
        let showingLatest = false;
        let wasWithinTiles = false;

        /** @type {number?} */
        let lastmax = null;
        /** @type {Date?} */
        let lastmaxDate = null;

        /**
         * The controller to immediately halt the extend___() methods.
         * Gets assigned a new controller everytime one of them gets called.
         * 
         * @type {AbortController?}
         */
        let fetchAbortController = null;

        /* utilities */

        /**
         * Returns the very date of a given date as an integer, allowing
         * for easier date comparisons. This returned date will be
         * timezone-aware.
         * 
         * @param {Date} date   The date to get the day value from.
         * @returns {number}    The day value of the date.
         */
        function getComparableDay(date) {
            return Math.floor((date.getTime() - (date.getTimezoneOffset() * 60*1000)) / (24*60*60*1000));
        }

        /* canvas utilities */

        function initializeCanvas() {
            offctx.lineCap = "butt";
            offctx.lineJoin = "round";
            offctx.lineWidth = 3;
            offctx.fillStyle = "#fff";
            offctx.strokeStyle = "#000";
            offctx.fillRect(0, 0, offcanv.width, offcanv.height);
        }

        /**
         * Renders the given sketch data and promises a URL of the render.
         *
         * @param {string} data
         * @param {number?} id
         *      For testing purposes.
         * @returns {Promise<string>}
         *      The Blob URL of the rendered sketch.
         */
        async function render(data, id=null) {
            /** @type {number[][][]} */
            const lines = [];
            for(const dataline of data.split(" ")) {
                const line = [];
                for(let pos = 0; pos < dataline.length; pos += 4) {
                    if(dataline.slice(pos, pos+4).length < 4) {
                        continue;
                    }

                    const x = parseInt(dataline.slice(pos, pos+2), 36);
                    const y = parseInt(dataline.slice(pos+2, pos+4), 36);
                    console.assert(!(isNaN(x) || isNaN(y)), id, dataline.slice(pos, pos+4));
                    line.push([x, y]);
                }
                lines.push(line);
            }

            offctx.fillRect(0, 0, offcanv.width, offcanv.height);
            for(const line of lines) {
                for(const pos in line) {
                    const [x, y] = line[pos];
                    if(pos == "0") {
                        offctx.beginPath();
                        offctx.moveTo(x, y);
                    }
                    else {
                        offctx.lineTo(x, y);
                    }
                }

                if(line.length) {
                    offctx.stroke();
                }
            }

            const blob = await offcanv.convertToBlob();
            const blobURL = URL.createObjectURL(blob);
            return blobURL;
        }

        /* endpoints */

        /**
         * @returns {Promise<Stats>}
         *      A promise that returns the current statistics of the
         *      gallery.
         */
        async function getStats() {
            const resp = await fetch("https://garyc.me/sketch/getStats.php?details");
            const stats = await resp.json();
            return stats;
        }

        /**
         * @param {number} id
         * @returns {Promise<SketchDetails?>}
         *      A promise that returns the details of a sketch.
         */
        async function getSketchDetails(id) {
            const resp = await fetch(
                `https://garyc.me/sketch/get.php?details&id=${id}`,
                {cache: "force-cache"}
            );

            const respText = await resp.text();
            const notFound = respText == "wait";
            if(notFound) {
                return null;
            }

            const details = JSON.parse(respText);
            return details;
        }

        /**
         * @param {number} id
         * @returns {string}
         *      The URL for a sketch with the ID.
         */
        function getImageURL(id) {
            return `https://garyc.me/sketch/getIMG.php?id=${id}&save`;
        }

        /* element factory methods */

        /**
         * @param {SketchDetails} details The sketch's details.
         */
        function createTile(details) {
            const tile = document.createElement("div");
            const tileImageA = document.createElement("a");
            const tileImage = document.createElement("img");
            const tileCaption = document.createElement("p");
            const tileSaveButton = document.createElement("button");
            const tileGIFButton = document.createElement("button");
            const tileActions = document.createElement("div");
            const tileStatus = document.createElement("div");

            if(settings.clientSideRendering) {
                tileImage.src = missingSketch;
                tileImage.classList.add("rendering");
                render(details.data, details.id).then((url) => {
                    tileImage.src = url;
                    tileImageA.href = tileImage.src;
                    tileImage.classList.remove("rendering");
                });
            }
            else {
                tileImage.classList.add("loading");
                tileImage.src = getImageURL(details.id);
                tileImage.addEventListener("load", () => {
                    tileImage.classList.remove("loading");
                });
                tileImageA.href = tileImage.src;
            }

            tileImage.classList.add("tile-image");
            tileImageA.classList.add("tile-image-holder");
            tileImageA.download = `${details.id}`;
            tileImageA.append(tileImage);
            tileImageA.addEventListener("click", (event) => {
                if(settings.clickSaving) {
                    return;
                }

                const oldOffset = tile.offsetTop;
                const willScrollToBottom = window.scrollY >= tile.offsetTop;

                tile.classList.toggle("expanded");

                // Scroll to the top of the tile instead of the bottom of the tile
                // whenever browsers tend to do that.
                if(willScrollToBottom) {
                    const newOffset = tile.offsetTop;
                    window.scrollTo(window.scrollX, newOffset);
                }

                event.preventDefault();
            });

            const inkRaw = details.data.length / 65535;
            const ink = Math.round(inkRaw * 1000) / 10;

            const linkParts = [
                "https://garyc.me",
                "/sketch",
                "/gallery.php",
                `#${details.id}`,
            ];
            const link = linkParts.join("");
            const linkWBR = linkParts.join("<wbr>");
            let timestamp = new Date(details.timestamp * 1000)
                .toLocaleString("default", {
                    weekday: "short",
                    month: "long",
                    day: "2-digit",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            const today = new Date();
            const yesterday = new Date(today.getTime() - 86_400_000);
            /** @type {Intl.DateTimeFormatOptions} */
            const dateOptions = {
                weekday: "short",
                month: "long",
                day: "2-digit",
                year: "numeric",
            };
            timestamp = timestamp
                .replace(today.toLocaleString("default", dateOptions), "Today")
                .replace(yesterday.toLocaleString("default", dateOptions), "Yesterday");

            const captionL = [
                `<i><a href=${link}>${linkWBR}</a></i>`,
                `${ink}% ink used`,
                `<i>from ${details.origin}</i>`,
                `<i>${timestamp}</i>`,
            ];
            const caption = captionL.join("<br>");
            tileCaption.innerHTML = caption;
            tileCaption.classList.add("tile-caption");

            // Putting this line over here feels a bit off...
            // can't I just put this near the tileImage chunk that's a couple lines up?
            tileImage.title = `#${details.id}, ${timestamp}`;

            if(lastmax != null && details.id > lastmax) {
                const newStatus = document.createElement("span");
                newStatus.innerHTML = "new!";
                newStatus.classList.add("new-status");
                tileStatus.classList.add("tile-status");
                tileStatus.append(newStatus);

                tile.classList.add("new");
            }

            const tileGIFLink = `https://garyc2gif.neocities.org/?id=${details.id}`;
            tileSaveButton.innerHTML = "save";
            tileGIFButton.innerHTML = "generate GIF on neocities &UpperRightArrow;";

            tileSaveButton.addEventListener("click", () => {
                // Can't use tileImageA directly because of how it's wired up to
                // handle tile expansion; use a plain <a> instead.
                const saveA = document.createElement("a");
                saveA.href = tileImageA.href;
                saveA.download = tileImageA.download;
                saveA.click();
            });
            tileGIFButton.addEventListener("click", () => window.open(tileGIFLink));

            tileActions.classList.add("tile-actions");
            tileActions.append(tileSaveButton);
            tileActions.append(tileGIFButton);
            tileCaption.append(tileActions);

            tile.setAttribute("ink", (ink * 10).toString());  // int-casted b/c i'm scared of floats
            tile.classList.add("tile", "anchorable");
            tile.append(tileImageA);
            tile.append(tileCaption);
            tile.append(tileStatus);

            if(ink < settings.inkFilterThreshold) {
                tile.classList.add("filtered");
            }

            return tile;
        }

        /**
         * @param {number} id The ID of the sketch that wasn't found.
         */
        function createNotFoundTile(id) {
            const dummy = document.createElement("div");
            const tileCaption = document.createElement("p");

            dummy.classList.add("tile-image-holder");
            tileCaption.innerHTML = `Can't get #${id}.`;
            tileCaption.classList.add("tile-caption");

            const tile = document.createElement("div");
            tile.classList.add("tile", "anchorable", "not-found");
            tile.append(dummy);
            tile.append(tileCaption);
            return tile;
        }

        /**
         * @param {Date} date The date labelled on the section.
         */
        function createSection(date) {
            const timestamp = date
                .toLocaleString("default", {
                    weekday: "short",
                    month: "long",
                    day: "2-digit",
                    year: "numeric",
                });

            const section = document.createElement("div");
            section.innerHTML = timestamp;
            section.classList.add("tile-section", "anchorable");
            return section;
        }

        /**
         * @param {number} id The first ID of a set of sketches that weren't found.
         */
        function createNotFoundSection(id) {
            let sectionHTML;
            if(id < min) {
                sectionHTML = `No sketches were found before #${min}.`;
            }
            else if(id > max) {
                sectionHTML = `No sketches were found after #${max}.`;
            }
            else {
                sectionHTML = `No sketches were found around #${id}.`;
            }

            const section = document.createElement("div");
            section.innerHTML = sectionHTML;
            section.classList.add("tile-section", "type-2");
            section.id = "not-found-section";
            return section;
        }

        /**
         * @param {number} id The first ID of the displayed set of sketches.
         */
        function createTileHeaderSection(id) {
            const section = document.createElement("div");
            section.innerHTML = `Showing from #${id}`;
            section.classList.add("tile-section", "type-2");
            section.id = "showing-header-section";
            return section;
        }

        /**
         * @param {number} oldmax   The previous max ID the page was last left at.
         * @param {Date} olddate    The date the page was last updated.
         * @param {number} newmax   The current max ID.
         * @returns {HTMLDivElement}
         */
        function createUnseenCountSection(oldmax, olddate, newmax) {
            const section = document.createElement("div");

            const now = new Date();
            const date = new Date(olddate);
            let sinceDate = date.toLocaleString("default", {
                hour: "2-digit",
                minute: "2-digit",
            });

            const nowDay = getComparableDay(now);
            const dateDay = getComparableDay(date);

            if(nowDay != dateDay) {
                // Yields a shorter date compared to the ones from tiles and date headers.
                // I don't think the date on this kind of header has to be *too* long.
                sinceDate = date.toLocaleString("default", {
                    month: "long",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            }

            const textE = document.createElement("span");
            const markReadE = document.createElement("a");  // i guess this makes sense...?
            const es = (newmax - oldmax) != 1 ? "es" : "";
            textE.innerHTML = `${newmax - oldmax} new sketch${es} since ${sinceDate}`;
            markReadE.role = "button";
            markReadE.tabIndex = 0;
            markReadE.innerHTML = "Mark as read";
            markReadE.id = "mark-read";
            markReadE.classList.add("section-text-right");
            markReadE.addEventListener("click", markGalleryAsRead);
            markReadE.addEventListener("keydown", (event) => event.key == "Enter" ? markGalleryAsRead() : null);

            section.append(textE, markReadE);
            section.classList.add("tile-section", "type-3");
            section.id = "unseen-section";
            return section;
        }

        function createGalleryEndSection() {
            const section = document.createElement("div");
            section.innerHTML = `End of the gallery.`;
            section.classList.add("tile-section", "type-2");
            section.id = "gallery-end-section";
            return section;
        }

        /* element updating methods */

        /**
         * @param {Stats} stats
         */
        function updateStats(stats) {
            const statsE = document.querySelector("#stats");
            const [sketchE, artistE, peekE] = statsE.children;

            function tag(strings, count, plural) {
                const [a, middle, b] = strings;
                const plingular = count != 1 ? plural : '';
                return `${count}${middle}${plingular}`;
            }

            sketchE.innerHTML = tag`${stats.sketches} sketch${'es'}`;
            artistE.innerHTML = tag`${stats.artists} artist${'s'}`;
            peekE.innerHTML = tag`${stats.peekers} peeker${'s'}`;
        }

        function markGalleryAsRead() {
            lastmax = max;
            lastmaxDate = new Date();
            updateStorageState();

            document.querySelectorAll(".new-status").forEach((elem) => elem.remove());
            document.querySelectorAll(".tile.new").forEach((tile) => tile.classList.remove("new"));
            const unseenSection = document.querySelector("#unseen-section");
            if(unseenSection) {
                unseenSection.remove();
            }

        }

        /* gallery extension methods */

        /**
         * Extends the bottom of the tile list.
         * 
         * @param {number} newlast
         */
        async function extendTo(newlast) {
            sketchesLoading = true;
            newlast = Math.max(newlast, min);

            fetchAbortController = new AbortController();
            const fetchAbortSignal = fetchAbortController.signal;

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            for(let id = last - 1; id >= newlast; id--) {
                const details = await getSketchDetails(id);

                if(fetchAbortSignal.aborted) {
                    return;
                }

                if(details) {
                    const tile = createTile(details);

                    const detailsDate = new Date(details.timestamp * 1000);
                    const detailsDay = getComparableDay(detailsDate);
                    const lastDay = lastDate ? getComparableDay(lastDate) : 0;

                    if(lastDay != detailsDay) {
                        const section = createSection(detailsDate);
                        tilesE.append(section);
                        lastDate = detailsDate;
                    }

                    if(!firstDate || !first) {
                        firstDate = detailsDate;
                        first = id;
                    }

                    tilesE.append(tile);
                }

                else {
                    const notFoundTile = createNotFoundTile(id);
                    tilesE.append(notFoundTile);
                }

                // add the footer of the gallery when necessary
                if(id == min) {
                    const section = createGalleryEndSection();
                    tilesE.append(section);
                }

                last = id;
            }

            sketchesLoading = false;
            moreButton.disabled = newlast == min;
        }

        /**
         * Extends the top of the tile list.
         * Unlike extendTo, `newfirst` won't be clamped to the gallery limits.
         * 
         * @param {number} newfirst
         */
        async function extendAbove(newfirst) {
            sketchesLoading = true;

            fetchAbortController = new AbortController();
            const fetchAbortSignal = fetchAbortController.signal;

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            const anchorSection = tilesE.querySelector(".tile-section.anchorable");
            let anchor = anchorSection;

            // going from oldest -> latest, because seeing new sketches that way
            // is probably more satisfying than the other way around

            for(let id = first + 1; id <= newfirst; id++) {
                const details = await getSketchDetails(id);

                if(fetchAbortSignal.aborted) {
                    return;
                }

                if(details) {
                    const tile = createTile(details);

                    const detailsDate = new Date(details.timestamp * 1000);
                    const detailsDay = getComparableDay(detailsDate);
                    const firstDay = firstDate ? getComparableDay(firstDate) : 0;

                    if(firstDay != detailsDay) {
                        const section = createSection(detailsDate);
                        anchor.before(section);
                        anchor = section;
                        firstDate = detailsDate;
                    }

                    if(!lastDate || !last) {
                        lastDate = detailsDate;
                        last = id;
                    }

                    anchor.after(tile);
                }

                else {
                    const notFoundTile = createNotFoundTile(id);
                    anchor.after(notFoundTile);
                }

                first = id;
            }

            sketchesLoading = false;
            moreButton.disabled = last == min;
        }

        /**
         * Rebuilds the entire tile list.
         * 
         * @param {number} newfirst
         */
        async function refreshFrom(newfirst) {
            if(fetchAbortController) {
                fetchAbortController.abort();
            }

            // "show more" button becomes disabled, and if there's no reason
            // down the road to re-enable it, it should stay disabled.
            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            // i would've used .children if HTMLCollection supported forEach()...
            // i need that syntactic sugar W3C
            tilesE.querySelectorAll("*").forEach(node => node.remove());

            if(newfirst < min || newfirst > max) {
                firstDate = null;
                lastDate = null;
                first = null;
                last = null;

                const section = createNotFoundSection(newfirst);
                tilesE.append(section);
                return;
            }

            if(!showingLatest) {
                const section = createTileHeaderSection(newfirst);
                tilesE.append(section);
            }

            if(showingLatest) {
                if(lastmax != null && max > lastmax) {
                    const section = createUnseenCountSection(lastmax, lastmaxDate, max);
                    tilesE.append(section);
                }
            }

            firstDate = null;
            lastDate = null;
            first = null;
            last = newfirst + 1;

            if(settings.clientSideRendering) {
                // Wait for the placeholder to be set up first before creating tiles.
                // This can also be seen as "wait for the off-canvas to be ready".
                // TODO: when createTile() becomes async, please put this over there instead.
                await missingSketchPromise;
            }
            extendTo(newfirst - 9);
        }

        /* background runners */

        async function maxLoop() {
            const refreshText = document.querySelector(".refresh-text");
            refreshText.classList.add("show");

            const stats = await getStats();
            const newmin = stats.minID;
            const newmax = stats.maxID;
            if(newmax > max) {
                if(showingLatest) {
                    const unseenSection = document.querySelector("#unseen-section");
                    const newSection = createUnseenCountSection(lastmax, lastmaxDate, newmax);
                    if(unseenSection) {
                        unseenSection.replaceWith(newSection);
                    }
                    else {
                        const tilesE = document.querySelector("#tiles");
                        tilesE.prepend(newSection);
                    }
                    extendAbove(newmax);
                }
                max = newmax;
            }

            min = newmin;

            updateStats(stats);
            refreshText.classList.remove("show");
        }

        /* settings and state */

        /**
         * Updates the localStorage state with the current state of the gallery.
         */
        function updateStorageState() {
            /** @type {GalleryState} */
            const state = {
                "last_max": max,
                "last_updated": Date.now(),
            };

            localStorage.setItem("tilegallery-state", JSON.stringify(state));
        }

        /**
         * @returns {Settings}
         */
        function getSettings() {
            /** @type {Settings} */
            const defaultSettings = {
                endlessScroll: true,
                gridView: false,
                clickSaving: false,
                clientSideRendering: true,
                pageTheme: "dark",
                gridImageSize: 200,
                wideGridView: false,
                inkFilterThreshold: 0,
            };

            const settings = JSON.parse(localStorage["tilegallery-settings"] || "{}");
            return {...defaultSettings, ...settings};
        }

        /**
         * @param {string} key
         * @param {any} value
         */
        function setSetting(key, value) {
            switch(key) {
                case "gridView": {
                    const toggled = value;
                    document.querySelector("#tiles").classList.toggle("block", toggled);
                    break;
                }
                case "pageTheme": {
                    document.documentElement.setAttribute("theme", value);
                    break;
                }
                case "gridImageSize": {
                    const pxValue = `${value}px`;
                    document.documentElement.style.setProperty("--grid-image-size", pxValue);
                    break;
                }
                case "wideGridView": {
                    const toggled = value;
                    document.body.classList.toggle("widened", toggled);
                    break;
                }
                case "inkFilterThreshold": {
                    const tilesE = document.querySelector("#tiles");
                    for(const tile of tilesE.querySelectorAll(".tile")) {
                        const ink10 = parseInt(tile.getAttribute("ink"));
                        const inkThreshold10 = value * 10;
                        const toggle = ink10 < inkThreshold10;
                        tile.classList.toggle("filtered", toggle);
                    }

                    const filtering = value > 0;
                    const note = document.querySelector(".filter-note-text");
                    note.classList.toggle("show", filtering);
                    break;
                }
                case "endlessScroll":
                case "clickSaving":
                case "clientSideRendering": {
                    // These are expected values! We don't really have to do anything with these.
                    // That being said, I might have to deal with unknown keys in a different way.
                    // This sounds like painful typing.
                    break;
                }
                default: {
                    console.warn(`Unknown key: ${key}`);
                }
            }

            settings[key] = value;
            localStorage.setItem("tilegallery-settings", JSON.stringify(settings));
        }

        /* main */

        function JSmain() {
            /** @type {GalleryState?} */
            const state = JSON.parse(localStorage.getItem("tilegallery-state"));
            if(state) {
                lastmax = state["last_max"];
                lastmaxDate = new Date(state["last_updated"]);
            }

            // Restore canvas context init after GPU crashes.
            // Canvas would've generated black sketches otherwise.
            offcanv.addEventListener("contextrestored", initializeCanvas);

            // Apply settings that need to be applied before the DOM is ready,
            // e.g. changing the theme on <html>.
            setSetting("pageTheme", settings.pageTheme);
        }

        async function main() {
            // DOM manipulation, etc.

            const settingsE = document.querySelector("#settings");
            const settingsInputs = settingsE.querySelectorAll("input");
            settingsInputs.forEach((elem) => {
                switch(elem.type) {
                    case "checkbox": {
                        // CHRIST this is the laziest implementation of a settings menu ever
                        // PLEASE fix this quabar
                        if(settings[elem.id]) {
                            setSetting(elem.id, settings[elem.id]);
                        }

                        elem.checked = settings[elem.id];
                        elem.addEventListener(
                            "change",
                            (event) => setSetting(elem.id, elem.checked)
                        );
                        break;
                    }
                    case "number": {
                        if(settings.hasOwnProperty(elem.id)) {
                            setSetting(elem.id, settings[elem.id]);
                        }

                        // Save hard-coded HTML value as default
                        const defaultValue = elem.value;

                        elem.value = settings[elem.id].toString();
                        elem.addEventListener(
                            "change",
                            (event) => {
                                const numvalue = parseInt(elem.value);

                                if(isNaN(numvalue)) {
                                    elem.value = defaultValue;
                                    setSetting(elem.id, parseInt(defaultValue));
                                    return;
                                }

                                setSetting(elem.id, numvalue);
                            }
                        );

                        break;
                    }
                }
            });
            const settingsSelects = settingsE.querySelectorAll("select");
            settingsSelects.forEach((select) => {
                if(settings[select.id]) {
                    setSetting(select.id, settings[select.id]);
                }

                const options = Array.from(select.options);
                const selValue = settings[select.id];
                const [selElem] = options.filter((option) => option.value == selValue);
                if(selElem) {
                    const index = options.indexOf(selElem);
                    select.selectedIndex = index;
                }

                select.addEventListener(
                    "change",
                    (event) => {
                        const selected = select.options[select.selectedIndex];
                        setSetting(select.id, selected.value);
                    }
                );
            });

            /** @type {HTMLInputElement} */
            const maxInputElem = document.querySelector("input#maxid");
            maxInputElem.addEventListener("change", (event) => {
                window.location.hash = maxInputElem.value;
            });

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.addEventListener("click", () => {
                extendTo(last - 10);
            });

            // Stats fetching, and updating anything that relies on it

            const refreshText = document.querySelector(".refresh-text");
            refreshText.classList.add("show");

            const stats = await getStats();
            min = stats.minID;
            max = stats.maxID;

            const state = localStorage.getItem("tilegallery-state");
            if(!state) {
                lastmax = max;
                lastmaxDate = new Date();
                updateStorageState();
            }

            updateStats(stats);

            maxInputElem.min = min.toString();  // ...why does this have to be a string?
            maxInputElem.max = max.toString();

            // let the hashchange handler do the ID handling work.
            // hugely inspired from sketch.rip.
            window.dispatchEvent(new HashChangeEvent("hashchange"));

            refreshText.classList.remove("show");
            setInterval(maxLoop, 30000);
        }

        JSmain();

        /* listeners */

        // Page events
        document.addEventListener("DOMContentLoaded", main);
        document.addEventListener("scroll", scrollHandler);
        document.addEventListener("wheel", scrollHandler);

        function scrollHandler() {
            if(sketchesLoading) {
                return;
            }

            if(settings.endlessScroll) {
                let pageHeight = document.documentElement.scrollHeight;
                let pageScroll = window.scrollY + window.innerHeight;
                let bottom = pageHeight - pageScroll <= 100;
                if(bottom) {
                    extendTo(last - 10);
                }
            }

            // Mark sketches as read, only when we've seen the maximum ID
            // that's currently on the gallery.
            /** @type {HTMLElement} */
            const tiles = document.querySelector("section#tiles");
            const tilesTop = tiles.offsetTop;
            const withinTiles = window.scrollY - tilesTop >= 0;
            if(showingLatest && withinTiles != wasWithinTiles) {
                updateStorageState();
                wasWithinTiles = withinTiles;
            }
        }

        window.addEventListener("hashchange", () => {
            /** @type {HTMLInputElement} */
            const maxInputElem = document.querySelector("input#maxid");

            const hashSlice = window.location.hash.slice(1);
            const hash = parseInt(hashSlice);
            if(!hashSlice || Number.isNaN(hash)) {
                showingLatest = true;
                refreshFrom(max);
                maxInputElem.value = "";
                return;
            }

            showingLatest = false;
            refreshFrom(hash);
            maxInputElem.value = hash.toString();
        });

        // Keyboard events
        document.addEventListener("keydown", (event) => {
            if(document.activeElement.nodeName == "INPUT") {
                return;
            }

            let modifiers = "";
            if(event.ctrlKey)   modifiers += "Ctrl+";
            if(event.altKey)    modifiers += "Alt+";
            if(event.shiftKey)  modifiers += "Shift+";
            if(event.metaKey)   modifiers += "Meta+";

            switch(modifiers + event.key) {
                case "Escape": {
                    const tilesE = document.querySelector("#tiles");
                    const expandeds = tilesE.querySelectorAll(".expanded");

                    if(expandeds.length == 0) {
                        break;
                    }

                    event.preventDefault();
                    expandeds.forEach((tile) => tile.classList.remove("expanded"));
                    break;
                }
                case "/":
                    /** @type {HTMLInputElement} */
                    const maxInputElem = document.querySelector("input#maxid");
                    maxInputElem.focus();
                    break;
                case "ArrowLeft":
                case "ArrowRight": {
                    if(!settings.gridView) {
                        break;
                    }

                    const tilesE = document.querySelector("#tiles");
                    /** @type {HTMLElement} */
                    const expanded = tilesE.querySelector(".expanded");
                    /** @type {HTMLElement} */
                    let newExpanded = null;
                    /** @type {ScrollBehavior} */
                    let scrollingBehavior = "instant";

                    if(!expanded) {
                        const firstTile = tilesE.querySelector(".tile:not(.filtered)");
                        // @ts-ignore
                        newExpanded = firstTile;
                    }
                    else {
                        const siblingDirection = event.key == "ArrowLeft"
                            ? "previousElementSibling"
                            : "nextElementSibling";

                        let anchor = expanded;
                        while(anchor[siblingDirection]) {
                            const sibling = anchor[siblingDirection];
                            // @ts-ignore
                            anchor = sibling;

                            if(sibling && sibling.matches(".tile:not(.filtered)")) {
                                // @ts-ignore
                                newExpanded = sibling;
                                break;
                            }
                        }
                    }
                    if(!newExpanded) {
                        break;
                    }

                    if(expanded) {
                        const expandedCenterOffset = (window.innerHeight - expanded.offsetHeight) / 2;
                        const expandedPos = expanded.offsetTop - Math.max(0, Math.floor(expandedCenterOffset));
                        if(Math.floor(window.scrollY) != expandedPos) {
                            scrollingBehavior = "smooth";
                        }
                    }
                    else {
                        scrollingBehavior = "smooth";
                    }

                    const expandedAll = document.querySelectorAll(".expanded");
                    expandedAll.forEach((elem) => elem.classList.remove("expanded"));
                    newExpanded.classList.add("expanded");

                    const scrollCenterOffset = (window.innerHeight - newExpanded.offsetHeight) / 2;
                    const scrollPos = newExpanded.offsetTop - Math.max(0, Math.floor(scrollCenterOffset));
                    window.scroll({
                        top: scrollPos,
                        // Known issue w/ Chrome:
                        // Scrolling with the wheel is known to interrupt programmatic smooth scrolling:
                        // https://issues.chromium.org/issues/40715316
                        behavior: scrollingBehavior,
                    });

                    const canExtend = settings.endlessScroll && !sketchesLoading;
                    if(canExtend && newExpanded.matches(":last-of-type")) {
                        extendTo(last - 10);
                    }

                    event.preventDefault();
                    break;
                }
            }
        });
    </script>
</head>
<body>
    <header>
        <h1>alt gallery!</h1>
        <ul id="stats">
            <li id="sketches"></li>
            <li id="artists"></li>
            <li id="peekers"></li>
        </ul>
        <nav>
            <search>
                <label for="maxid">Jump to ID:</label>
                <input type="number" id="maxid">
            </search>
            <div class="refresh-text">
                refreshing...
            </div>
        </nav>
    </header>
    <main>
        <section id="prelude">
            <details id="settings">
                <summary>Gallery preferences</summary>
                <div class="setting">
                    <label for="inkFilterThreshold">Ink filter (%):</label>
                    <input type="number" id="inkFilterThreshold" min="0" max="100" value="0" step="5">
                </div>
                <div class="setting">
                    <label for="gridImageSize">Grid thumbnail size:</label>
                    <select id="gridImageSize">
                        <option value="130">1/7</option>
                        <option value="160">1/5</option>
                        <option value="200">1/4</option>
                        <option value="280">1/3</option>
                        <option value="360">Half</option>
                        <option value="800" title="Won't exactly be a 'grid' view anymore but...">Full</option>
                    </select>
                </div>
                <div class="setting">
                    <label for="pageTheme">Webpage theme:</label>
                    <select id="pageTheme">
                        <option value="dark">Dark</option>
                        <option value="light">Light</option>
                    </select>
                </div>
                <div class="setting">
                    <label for="endlessScroll">Endless scrolling:</label>
                    <input type="checkbox" id="endlessScroll">
                </div>
                <div class="setting">
                    <label for="gridView">Grid view:</label>
                    <input type="checkbox" id="gridView">
                </div>
                <div class="setting">
                    <label for="wideGridView">Expanded grid view:</label>
                    <input type="checkbox" id="wideGridView">
                </div>
                <div class="setting">
                    <label for="clientSideRendering">Client-side sketch rendering:</label>
                    <input type="checkbox" id="clientSideRendering">
                </div>
                <div class="setting">
                    <label for="clickSaving">Save sketch on thumbnail click/tap:</label>
                    <input type="checkbox" id="clickSaving">
                </div>
                <i>current version: <span id="version">v0.7.0</span></i>
            </details>

            <p>
                An alternative gallery for
                <a href="https://garyc.me/sketch/gallery.php">garyc.me/sketch</a>.<br>
                Features endless scrolling, and a grid-like view.<br>
                Originally meant for viewing my sketch archives, but people started liking the layout.
            </p>

            <ul>
                <li>Clicking/tapping on the sketches expands the sketch into full size.</li>
                <li>Middle-clicking on the sketches saves the sketch.</li>
                <li>Pressing <kbd>Esc</kbd> would collapse any expanded sketches.</li>
                <li>Pressing <kbd>/</kbd> would jump to the ID field.</li>
                <li>Pressing <kbd></kbd> or <kbd></kbd> would navigate across sketches (in grid view).</li>
                <li>Leaving the ID field blank would show the latest sketches on the gallery.</li>
            </ul>
        </section>
        <section id="tiles">
            <noscript>
                <div class="tile-section type-2">
                    You need to enable JavaScript to use the gallery.
                </div>
            </noscript>
        </section>
        <footer>
            <i class="filter-note-text">note: an ink filter is currently active</i>
            <button id="more">show more</button>
        </footer>
    </main>
</body>
</html>
