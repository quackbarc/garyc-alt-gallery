
<!-- v0.5.0, by quackbarc. Licensed under GPL. -->
<!-- Fantasque Sans Mono is licensed under OFL: https://github.com/belluzj/fantasque-sans -->

<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" media="screen" href="https://fontlibrary.org//face/fantasque-sans-mono" type="text/css"/>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>an alt gallery using tiles</title>

    <style>
        html {
            color-scheme: dark;
        }

        body {
            padding: 10px;
            font-family: "Fantasque Sans Mono", monospace;
            max-width: 1000px;
            margin: auto;

            background-color: #111;
            color: #fff;
        }

        a, a:visited {
            color: #808fff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        i, i > a {
            color: #fff9;
        }

        /* <header> styles */

        header {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0px 10px;

            position: sticky;
            top: 0px;
            background-color: #111;
        }

        h1 {
            text-align: left;
            flex: 0 0 auto;
        }

        header > ul {
            text-align: left;
            list-style: none;
            padding: 0;
            font-size: 14px;

            flex: 1 0 auto;
        }

        nav {
            text-align: right;
            flex: 0 1 auto;
            align-self: flex-end;
            padding: 10px 0px;

            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        nav input {
            /**
             * Prefer light color-scheme for the nav inputs,
             * just so it stands out a little. */
            color-scheme: light;
        }

        nav .refresh-text {
            visibility: hidden;
            color: #fff9;
        }

        nav .refresh-text.show {
            visibility: visible;
        }

        /* settings styles */

        #settings {
            /* styles specifically for its position in <main> */
            float: right;
            padding: 10px;
            margin: 0px 10px 10px;

            user-select: none;
            text-align: right;
            background-color: #444;
            border-bottom: 2px solid #0003;
        }

        #settings > summary {
            cursor: pointer;
        }

        #settings > summary:hover {
            text-decoration: underline;
        }

        #settings[open] > summary {
            padding-bottom: 4px;
        }

        #settings > * > input {
            /**
             * Align the input elements to the bottom of the text.
             * Worked for checkboxes so far; hope it works for the others. */
            vertical-align: bottom;
        }

        /* <footer> styles */

        footer {
            text-align: center;
        }

        /* <main> styles */

        main {
            padding: 10px;
            border: 2px solid #0003;
            overflow-wrap: anywhere;

            background-color: #333;
        }

        .tile {
            display: flex;
            align-items: center;
            text-align: left;
            width: 100%;
            padding: 12px 0px;
            gap: 6px;

            /* for the column-based formats */
            grid-template-areas:
                "img  img"
                "capt stat";
            grid-template-columns: auto min-content;
        }

        .tile :first-child {
            flex: 0 1 auto;
        }

        .tile > :first-child:not(img),    /* (<-- for dummy left-column tiles that aren't images) */
        .tile img.tile-image {
            width: 400px;
            grid-area: img;
        }

        .tile .tile-caption {
            flex: 1 1 auto;
            padding: 0px 6px;
            margin: 0;
            grid-area: capt;
        }

        .tile .tile-status {
            flex: 0 1 auto;
            writing-mode: vertical-rl;
            grid-area: stat;
        }

        .tile .tile-status span {
            display: inline-block;
            padding: 5px;
        }

        .tile .tile-status .new-status {
            background-color: #484cbb;
        }

        /* Unused; for expand-on-click tiles */
        .tile.selected {
            flex-direction: column;
            gap: 12px;
        }

        /* Unused; for expand-on-click tiles */
        .tile.selected > :first-child:not(img),
        .tile.selected img.tile-image {
            width: 100%;
        }

        .tile-section {
            background-color: #fff;
            color: #000;
            text-align: center;
            padding: 12px;
            margin: 8px 0px;
        }

        .tile-section.type-2 {
            background-color: #444;
            color: #fff;
        }

        .tile-section.type-3 {
            background-color: #484cbb;
            color: #fff;
        }

        .tile-section + .tile-section {
            margin-top: 10px;
        }

        /* block-based format */

        #tiles.block {
            text-align: center;
        }

        #tiles.block .tile:not(.expanded) {
            display: inline-block;
            padding: 8px;
            width: auto;
        }

        #tiles.block .tile:not(.expanded) :not(:first-child) {
            display: none;
        }

        #tiles.block .tile:not(.expanded) > :first-child:not(img),
        #tiles.block .tile:not(.expanded) img.tile-image {
            width: 200px;
        }

        /* column-based format */

        .tile.expanded {
            display: inline-grid;
            text-align: left;
            max-width: 800px;
        }

        .tile.expanded :first-child:not(img),
        .tile.expanded img.tile-image {
            width: 100%;
        }

        .tile.expanded .tile-caption {
            padding: 6px 10px;
        }

        .tile.expanded .tile-status span {
            /* Way too big of a padding on the left, probably caused by writing-mode..? */
            padding-left: 0px;
        }

        /* other media queries */

        @media (max-width: 800px) {
            .tile > :first-child:not(img),
            .tile img.tile-image {
                width: 250px;
            }

            /* settings styles */

            #settings {
                float: none;
                text-align: left;
                margin-left: 0;
                margin-right: 0;
            }

            #settings .setting {
                display: flex;
            }

            #settings .setting label {
                flex-grow: 1;
            }
        }

        /* column-based format */

        @media (max-width: 550px) {
            /* <header> styles */

            header {
                display: grid;
                grid-template-areas:
                    "h1 h1 "
                    "ul nav";
                gap: 0px;

                position: unset;
            }

            header > h1 {
                grid-area: h1;
            }

            header > ul {
                grid-area: ul;
            }

            header > nav {
                grid-area: nav;
            }

            /* <main> styles */

            .tile {
                display: grid;
            }
            .tile :first-child:not(img),
            .tile img.tile-image {
                width: 100%;
            }
            .tile .tile-caption {
                padding: 6px 10px;
            }
            .tile .tile-status span {
                /* Way too big of a padding on the left, probably caused by writing-mode..? */
                padding-left: 0px;
            }
        }
    </style>

    <script>
        // @ts-check

        /* type definitions */

        /**
         * The archive details of a sketch.
         * 
         * @typedef {object} SketchDetails
         * @property {number} id
         * @property {string} data
         * @property {number} archive_timestamp
         * @property {number?} timestamp
         * @property {string?} origin
         */

        /**
         * The current statistics of the gallery.
         * 
         * @typedef {object} Stats
         * @property {number} sketches
         * @property {number} artists
         * @property {number} peekers
         * @property {number} minID
         * @property {number} maxID
         */

        /**
         * The state of the gallery from when it left off.
         * 
         * @typedef {object} GalleryState
         * @property {number} last_max
         * @property {number} last_updated
         */

        /**
         * The current loading state of the gallery's tiles.
         * 
         * @typedef {"idle" | "loading" | "gallery-end"} LoadingState
         */

        /**
         * The user configuration of the gallery. Settings, if you insist.
         *
         * @typedef {object} Settings
         * @property {boolean} endlessScroll
         * @property {boolean} gridView
         * @property {boolean} clickSaving
         */

        /* constants */

        // gallery settings

        const settings = getSettings();

        // gallery state

        /** @type {number?} */
        let min = null;
        /** @type {number?} */
        let max = null;
        /** @type {number?} */
        let first = null;
        /** @type {number?} */
        let last = null;
        /** @type {Date?} */
        let firstDate = null;
        /** @type {Date?} */
        let lastDate = null;
        /** Whether tiles are currently being added or not. */
        let sketchesLoading = false;
        /**
         * The current state of the gallery tile loading.
         * @type {LoadingState}
         */
        let loadingState = "idle";
        /**
         * Whether the gallery is currently supposed to be showing the latest
         * sketches, or not.
         */
        let showingLatest = false;

        let holdingShift = false;

        /** @type {number?} */
        let lastmax = null;
        /** @type {Date?} */
        let lastmaxDate = null;

        /* utilities */

        /**
         * Returns the very date of a given date as an integer, allowing
         * for easier date comparisons. This returned date will be
         * timezone-aware.
         * 
         * @param {Date} date   The date to get the day value from.
         * @returns {number}    The day value of the date.
         */
        function getComparableDay(date) {
            return Math.floor((date.getTime() - (date.getTimezoneOffset() * 60*1000)) / (24*60*60*1000));
        }

        /* endpoints */

        /**
         * @returns {Promise<number[]>}
         *      A promise that returns a two-tuple of the
         *      gallery's minimum and maximum IDs.
         */
        async function getMinMax() {
            const {minID, maxID} = await getStats();
            return [minID, maxID];
        }

        /**
         * @returns {Promise<Stats>}
         *      A promise that returns the current statistics of the
         *      gallery.
         */
        async function getStats() {
            const resp = await fetch("https://garyc.me/sketch/getStats.php?details");
            const stats = await resp.json();
            return stats;
        }

        /**
         * @param {number} id
         * @returns {Promise<SketchDetails>}
         *      A promise that returns the details of a sketch.
         */
        async function getSketchDetails(id) {
            const resp = await fetch(
                `https://garyc.me/sketch/get.php?details&id=${id}`,
                {cache: "force-cache"}
            );
            const details = await resp.json();
            return details;
        }

        /**
         * @param {number} id
         * @returns {string}
         *      The URL for a sketch with the ID.
         */
        function getImageURL(id) {
            return `https://garyc.me/sketch/getIMG.php?id=${id}&save`;
        }

        /* element factory methods */

        /**
         * @param {SketchDetails} details The sketch's details.
         */
        function createTile(details) {
            const tile = document.createElement("div");
            const tileImageA = document.createElement("a");
            const tileImage = document.createElement("img");
            const tileCaption = document.createElement("p");
            const tileStatus = document.createElement("div");

            tileImage.src = getImageURL(details.id);
            tileImage.classList.add("tile-image");
            tileImageA.href = tileImage.src;
            tileImageA.download = `${details.id}`;
            tileImageA.append(tileImage);
            tileImageA.addEventListener("click", (event) => {
                if(settings.clickSaving) {
                    return;
                }

                tile.classList.toggle("expanded");
                event.preventDefault();
            });

            // TODO: feature:
            // - tile.scrollIntoView();
            // - requires all the tiles to have the css "scroll-margin-top: 100px;"

            // TODO: bugfix
            // race condition continues when loading images, but ID gets jumped

            const ink = details.data.length / 65535;
            const link = `https://garyc.me/sketch/gallery.php#${details.id}`
            let timestamp = new Date(details.timestamp * 1000)
                .toLocaleString("default", {
                    weekday: "short",
                    month: "long",
                    day: "2-digit",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            const today = new Date();
            const yesterday = new Date(today.getTime() - 86_400_000);
            /** @type {Intl.DateTimeFormatOptions} */
            const dateOptions = {
                weekday: "short",
                month: "long",
                day: "2-digit",
                year: "numeric",
            };
            timestamp = timestamp
                .replace(today.toLocaleString("default", dateOptions), "Today")
                .replace(yesterday.toLocaleString("default", dateOptions), "Yesterday");
            const captionL = [
                `<i><a href=${link}>${link}</a></i>`,
                `${Math.floor(ink * 1000) / 10}% ink used`,
                `<i>from ${details.origin}</i>`,
                `<i>${timestamp}</i>`,
            ];
            const caption = captionL.join("<br>");
            tileCaption.innerHTML = caption;
            tileCaption.classList.add("tile-caption");

            // Putting this line over here feels a bit off...
            // can't I just put this near the tileImage chunk that's a couple lines up?
            tileImage.title = `#${details.id}, ${timestamp}`;

            if(lastmax != null && details.id > lastmax) {
                const newStatus = document.createElement("span");
                newStatus.innerHTML = "new!";
                newStatus.classList.add("new-status");
                tileStatus.classList.add("tile-status");
                tileStatus.append(newStatus);
            }

            tile.classList.add("tile", "anchorable");
            tile.append(tileImageA);
            tile.append(tileCaption);
            tile.append(tileStatus);

            return tile;
        }

        /**
         * @param {number} id The ID of the sketch that wasn't found.
         */
        function createNotFoundTile(id) {
            const dummy = document.createElement("div");
            const tileCaption = document.createElement("p");
            tileCaption.innerHTML = `Can't get #${id}.`;
            tileCaption.classList.add("tile-caption");

            const tile = document.createElement("div");
            tile.classList.add("tile");
            tile.append(dummy);
            tile.append(tileCaption);
            return tile;
        }

        /**
         * @param {Date} date The date labelled on the section.
         */
        function createSection(date) {
            const timestamp = date
                .toLocaleString("default", {
                    weekday: "short",
                    month: "long",
                    day: "2-digit",
                    year: "numeric",
                });

            const section = document.createElement("div");
            section.innerHTML = timestamp;
            section.classList.add("tile-section", "anchorable");
            return section;
        }

        /**
         * @param {number} id The first ID of a set of sketches that weren't found.
         */
        function createNotFoundSection(id) {
            let sectionHTML;
            if(id < min) {
                sectionHTML = `No sketches were found before #${min}.`;
            }
            else if(id > max) {
                sectionHTML = `No sketches were found after #${max}.`;
            }
            else {
                sectionHTML = `No sketches were found around #${id}.`;
            }

            const section = document.createElement("div");
            section.innerHTML = sectionHTML;
            section.classList.add("tile-section", "type-2");
            return section;
        }

        /**
         * @param {number} id The first ID of the displayed set of sketches.
         */
        function createTileHeaderSection(id) {
            const section = document.createElement("div");
            section.innerHTML = `Showing from #${id}`;
            section.classList.add("tile-section", "type-2");
            return section;
        }

        /**
         * @param {number} oldmax   The previous max ID the page was last left at.
         * @param {Date} olddate    The date the page was last updated.
         * @param {number} newmax   The current max ID.
         * @returns {HTMLDivElement}
         */
        function createUnseenCountSection(oldmax, olddate, newmax) {
            const section = document.createElement("div");

            const now = new Date();
            const date = new Date(olddate);
            let sinceDate = date.toLocaleString("default", {
                hour: "2-digit",
                minute: "2-digit",
            });

            const nowDay = getComparableDay(now);
            const dateDay = getComparableDay(date);

            if(nowDay != dateDay) {
                // Yields a shorter date compared to the ones from tiles and date headers.
                // I don't think the date on this kind of header has to be *too* long.
                sinceDate = date.toLocaleString("default", {
                    month: "long",
                    day: "2-digit",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            }

            section.innerHTML = `${newmax - oldmax} new sketch(es) since ${sinceDate}`;
            section.classList.add("tile-section", "type-3");
            return section;
        }

        function createGalleryEndSection() {
            const section = document.createElement("div");
            section.innerHTML = `End of the gallery.`;
            section.classList.add("tile-section", "type-2");
            return section;
        }

        /* element updating methods */

        /**
         * @param {Stats} stats
         */
        function updateStats(stats) {
            const statsE = document.querySelector("#stats");
            const [sketchE, artistE, peekE] = statsE.children;

            function tag(strings, count, plural) {
                const [a, middle, b] = strings;
                const plingular = count != 1 ? plural : '';
                return `${count}${middle}${plingular}`;
            }

            sketchE.innerHTML = tag`${stats.sketches} sketch${'es'}`;
            artistE.innerHTML = tag`${stats.artists} artist${'s'}`;
            peekE.innerHTML = tag`${stats.peekers} peeker${'s'}`;
        }

        /* gallery extension methods */

        /**
         * Extends the bottom of the tile list.
         * 
         * @param {number} newlast
         */
        async function extendTo(newlast) {
            sketchesLoading = true;
            newlast = Math.max(newlast, min);

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            for(let id = last - 1; id >= newlast; id--) {
                const details = await getSketchDetails(id);
                const tile = createTile(details);

                const detailsDate = new Date(details.timestamp * 1000);
                const detailsDay = getComparableDay(detailsDate);
                const lastDay = lastDate ? getComparableDay(lastDate) : 0;

                if(lastDay != detailsDay) {
                    const section = createSection(detailsDate);
                    tilesE.append(section);
                    lastDate = detailsDate;
                }

                if(!firstDate || !first) {
                    firstDate = detailsDate;
                    first = id;
                }

                tilesE.append(tile);

                // add the footer of the gallery when necessary
                if(id == min) {
                    const section = createGalleryEndSection();
                    tilesE.append(section);
                }
            }

            const endOfGallery = newlast == min;

            last = newlast;
            sketchesLoading = false;

            moreButton.disabled = endOfGallery;
        }

        /**
         * Extends the top of the tile list.
         * Unlike extendTo, `newfirst` won't be clamped to the gallery limits.
         * 
         * @param {number} newfirst
         */
        async function extendAbove(newfirst) {
            sketchesLoading = true;

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            const anchorSection = tilesE.querySelector(".tile-section.anchorable");
            let anchor = anchorSection;

            // going from oldest -> latest, because seeing new sketches that way
            // is probably more satisfying than the other way around

            for(let id = first + 1; id <= newfirst; id++) {
                const details = await getSketchDetails(id);
                const tile = createTile(details);

                const detailsDate = new Date(details.timestamp * 1000);
                const detailsDay = getComparableDay(detailsDate);
                const firstDay = firstDate ? getComparableDay(firstDate) : 0;

                if(firstDay != detailsDay) {
                    const section = createSection(detailsDate);
                    anchor.before(section);
                    anchor = section;
                    firstDate = detailsDate;
                }

                if(!lastDate || !last) {
                    lastDate = detailsDate;
                    last = id;
                }

                anchor.after(tile);
            }

            const endOfGallery = last == min;

            first = newfirst;
            sketchesLoading = false;

            moreButton.disabled = endOfGallery;
        }

        /**
         * Rebuilds the entire tile list.
         * 
         * @param {number} newfirst
         */
        async function refreshFrom(newfirst) {
            // "show more" button becomes disabled, and if there's no reason
            // down the road to re-enable it, it should stay disabled.
            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.disabled = true;

            const tilesE = document.querySelector("#tiles");
            // i would've used .children if HTMLCollection supported forEach()...
            // i need that syntactic sugar W3C
            tilesE.querySelectorAll("*").forEach(node => node.remove());

            if(newfirst < min || newfirst > max) {
                firstDate = null;
                lastDate = null;
                first = null;
                last = null;

                const section = createNotFoundSection(newfirst);
                tilesE.append(section);
                return;
            }

            if(!showingLatest) {
                const section = createTileHeaderSection(newfirst);
                tilesE.append(section);
            }

            if(showingLatest) {
                if(lastmax != null && max > lastmax) {
                    const section = createUnseenCountSection(lastmax, lastmaxDate, max);
                    tilesE.append(section);
                }
            }

            firstDate = null;
            lastDate = null;
            first = null;
            last = newfirst + 1;
            extendTo(newfirst - 10);
        }

        /* uh hey quackbarc we should put this somewhere */

        /**
         * Updates the localStorage state with the current state of the gallery.
         */
        function updateStorageState() {
            /** @type {GalleryState} */
            const state = {
                "last_max": max,
                "last_updated": Date.now(),
            };

            localStorage.setItem("tilegallery-state", JSON.stringify(state));
        }

        /* background runners */

        async function maxLoop() {
            const refreshText = document.querySelector(".refresh-text");
            refreshText.classList.add("show");

            const stats = await getStats();
            const newmin = stats.minID;
            const newmax = stats.maxID;
            if(newmax > max) {
                if(showingLatest) {
                    extendAbove(newmax);
                }
                max = newmax;
            }

            updateStorageState();
            updateStats(stats);
            refreshText.classList.remove("show");
        }

        /* settings */

        /**
         * @returns {Settings}
         */
        function getSettings() {
            /** @type {Settings} */
            const defaultSettings = {
                endlessScroll: true,
                gridView: false,
                clickSaving: false,
            };

            const settings = JSON.parse(localStorage.settings || "{}");
            return {...defaultSettings, ...settings};
        }

        /**
         * @param {string} key
         * @param {any} value
         */
        function setSetting(key, value) {
            switch(key) {
                case "gridView": {
                    const toggled = value;
                    document.querySelector("#tiles").classList.toggle("block", toggled);
                    break;
                }
                case "endlessScroll":
                case "clickSaving": {
                    // These are expected values! We don't really have to do anything with these.
                    // That being said, I might have to deal with unknown keys in a different way.
                    // This sounds like painful typing.
                    break;
                }
                default: {
                    console.warn(`Unknown key: ${key}`);
                }
            }

            settings[key] = value;
            localStorage.setItem("settings", JSON.stringify(settings));
        }

        /* main */

        function JSmain() {
            /** @type {GalleryState?} */
            const state = JSON.parse(localStorage.getItem("tilegallery-state"));
            if(state) {
                lastmax = state["last_max"];
                lastmaxDate = new Date(state["last_updated"]);
            }
        }

        async function main() {
            const refreshText = document.querySelector(".refresh-text");
            refreshText.classList.add("show");

            const settingsE = document.querySelector("#settings");
            const settingsInputs = settingsE.querySelectorAll("input");
            settingsInputs.forEach((elem) => {
                switch(elem.type) {
                    case "checkbox": {
                        // CHRIST this is the laziest implementation of a settings menu ever
                        // PLEASE fix this quabar
                        if(settings[elem.id]) {
                            setSetting(elem.id, settings[elem.id]);
                        }

                        elem.checked = settings[elem.id];
                        elem.addEventListener(
                            "change",
                            (event) => setSetting(elem.id, elem.checked)
                        );
                        break;
                    }
                }
            });

            const stats = await getStats();
            min = stats.minID;
            max = stats.maxID;
            updateStats(stats);

            /** @type {HTMLInputElement} */
            const maxInputElem = document.querySelector("input#maxid");
            // ...really? the string casting?
            maxInputElem.min = min.toString();
            maxInputElem.max = max.toString();
            maxInputElem.addEventListener("change", (event) => {
                window.location.hash = maxInputElem.value;
            });

            /** @type {HTMLButtonElement} */
            const moreButton = document.querySelector("button#more");
            moreButton.addEventListener("click", () => {
                extendTo(last - 10);
            });

            // let the hashchange handler do the ID handling work.
            // hugely inspired from sketch.rip.
            window.dispatchEvent(new HashChangeEvent("hashchange"));

            refreshText.classList.remove("show");
            setInterval(maxLoop, 30000);
        }

        JSmain();

        /* listeners */

        // Page events
        document.addEventListener("DOMContentLoaded", main);
        document.addEventListener("scroll", () => {
            if(sketchesLoading) {
                return;
            }

            if(!settings.endlessScroll) {
                return;
            }

            let pageHeight = document.documentElement.scrollHeight;
            let pageScroll = window.scrollY + window.innerHeight;
            let bottom = pageHeight - pageScroll <= 100;
            if(bottom) {
                extendTo(last - 10);
            }
        });
        window.addEventListener("hashchange", () => {
            /** @type {HTMLInputElement} */
            const maxInputElem = document.querySelector("input#maxid");

            const hashSlice = window.location.hash.slice(1);
            const hash = parseInt(hashSlice);
            if(!hashSlice || Number.isNaN(hash)) {
                showingLatest = true;
                refreshFrom(max);
                maxInputElem.value = "";
                return;
            }

            showingLatest = false;
            refreshFrom(hash);
            maxInputElem.value = hash.toString();
        });
        window.addEventListener("pagehide", updateStorageState.bind(this));

        // Keyboard events
        document.addEventListener("keydown", (event) => {
            const noModifiers = !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey;
            switch(event.key) {
                case "/":
                    if(!noModifiers) {
                        break;
                    }

                    /** @type {HTMLInputElement} */
                    const maxInputElem = document.querySelector("input#maxid");
                    maxInputElem.focus();
                    break;
            }
        });

        /* keyboard listeners */

        document.addEventListener("keydown", (event) => {
            if(event.key == "Shift") {
                holdingShift = true;
            }
        });
        document.addEventListener("keyup", (event) => {
            if(event.key == "Shift") {
                holdingShift = false;
            }
        });
    </script>
</head>
<body>
    <header>
        <h1>alt gallery!</h1>
        <ul id="stats">
            <li id="sketches"></li>
            <li id="artists"></li>
            <li id="peekers"></li>
        </ul>
        <nav>
            <search>
                <label for="maxid">Jump to ID:</label>
                <input type="number" id="maxid">
            </search>
            <div class="refresh-text">
                refreshing...
            </div>
        </nav>
    </header>
    <main>
        <section id="prelude">
            <details id="settings">
                <summary>Gallery preferences</summary>
                <div class="setting">
                    <label for="endlessScroll">Endless scrolling:</label>
                    <input type="checkbox" id="endlessScroll">
                </div>
                <div class="setting">
                    <label for="gridView">Grid view:</label>
                    <input type="checkbox" id="gridView">
                </div>
                <div class="setting">
                    <label for="clickSaving">Save sketch on thumbnail click/tap:</label>
                    <input type="checkbox" id="clickSaving">
                </div>
            </details>

            <p>
                An alternative gallery for
                <a href="https://garyc.me/sketch/gallery.php">garyc.me/sketch</a>.<br>
                Features endless scrolling, and a grid-like view.<br>
                Originally meant for viewing my sketch archives, but people started liking the layout.
            </p>

            <p>
                Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
                tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
                quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
                consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
                proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
            </p>

            <p>
                Controls:
            </p>

            <ul>
                <li>Clicking/tapping on the sketches expands the sketch into full size.</li>
                <li>Middle-clicking on the sketches saves the sketch.</li>
                <li>Pressing "/" would jump to the ID field.</li>
                <li>Leaving the ID field blank would show the latest sketches on the gallery.</li>
            </ul>
        </section>
        <section id="tiles"></section>
        <footer>
            <button id="more">show more</button>
        </footer>
    </main>
</body>
</html>
